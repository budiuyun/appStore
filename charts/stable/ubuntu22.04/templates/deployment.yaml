apiVersion: apps/v1
kind: Deployment
metadata:
  name: {{ include "ubuntu-22-04.fullname" . }}
  labels:
    {{- include "ubuntu-22-04.labels" . | nindent 4 }}
spec:
  replicas: {{ .Values.replicaCount }}
  selector:
    matchLabels:
      {{- include "ubuntu-22-04.selectorLabels" . | nindent 6 }}
  template:
    metadata:
      labels:
        {{- include "ubuntu-22-04.selectorLabels" . | nindent 8 }}
      annotations:
        # 添加注解，每次升级Chart时触发重新部署
        pv.initialize/timestamp: "{{ now | date "20060102150405" }}"
    spec:
      {{- if and .Values.persistence.enabled .Values.persistence.mounts }}
      # 数据初始化容器
      initContainers:
        - name: data-init
          image: "{{ .Values.image.imageRegistry }}/{{ .Values.image.repository }}:{{ .Values.image.tag }}"
          env:
            # 添加是否强制重新初始化的环境变量，默认为false
            - name: FORCE_INIT
              value: "{{ .Values.persistence.forceInit | default "false" }}"
          # 使用通用的数据初始化命令，适用于任何类型的应用
          command: ["/bin/sh", "-c"]
          args:
            - |
              # 遍历所有挂载点
              {{- range $index, $path := .Values.persistence.mounts }}
              # 检查是否需要初始化 - 如果强制初始化参数为true，或者没有初始化标志文件
              if [ "$FORCE_INIT" = "true" ] || [ ! -f "/pv-data{{ $path }}/.data_initialized" ]; then
                echo "初始化挂载点 {{ $path }} 的数据..."
                # 创建目标目录结构
                mkdir -p /pv-data{{ $path }}
                # 确保临时目录存在
                mkdir -p /temp-data{{ $path }}
                # 复制原始目录内容到临时存储，包括所有子目录
                if [ -d "{{ $path }}" ]; then
                  echo "备份 {{ $path }} 的原始数据(包括子目录)..."
                  # 使用rsync或cp命令递归复制数据（如果rsync可用）
                  if command -v rsync > /dev/null 2>&1; then
                    # rsync可以完整保留权限和目录结构
                    rsync -a "{{ $path }}/" "/temp-data{{ $path }}/" 2>/dev/null || true
                  else
                    # 创建所有子目录结构
                    find "{{ $path }}" -type d -exec mkdir -p "/temp-data{}" \; 2>/dev/null || true
                    # 复制所有文件，保留权限
                    find "{{ $path }}" -type f -exec cp -a {} "/temp-data{}" \; 2>/dev/null || true
                    # 复制所有符号链接
                    find "{{ $path }}" -type l -exec cp -a {} "/temp-data{}" \; 2>/dev/null || true
                  fi
                  echo "{{ $path }} 原始数据备份完成"
                fi
              else
                echo "{{ $path }} 已初始化，跳过备份步骤"
              fi
              {{- end }}
          resources:
            {{- toYaml .Values.resources | nindent 12 }}
          volumeMounts:
            # 挂载临时数据卷
            - name: temp-data
              mountPath: /temp-data
            # 挂载持久卷，但使用不同路径前缀
            - name: data
              mountPath: /pv-data
      {{- end }}
      containers:
        - name: {{ .Chart.Name }}
          image: "{{ .Values.image.imageRegistry }}/{{ .Values.image.repository }}:{{ .Values.image.tag }}"
          imagePullPolicy: {{ .Values.image.pullPolicy }}
          {{- if and .Values.persistence.enabled .Values.persistence.mounts }}
          env:
            # 添加是否强制重新初始化的环境变量
            - name: FORCE_INIT
              value: "{{ .Values.persistence.forceInit | default "false" }}"
            {{- if .Values.env }}
            {{- range $key, $value := .Values.env }}
            - name: {{ $value.name }}
              value: {{ $value.value | quote }}
            {{- end }}
            {{- end }}
          # 添加应用容器启动脚本
          command: ["/bin/sh", "-c"]
          args:
            - |
              # 为每个挂载点迁移数据
              {{- range $index, $path := .Values.persistence.mounts }}
              # 检查是否需要初始化 - 如果强制初始化参数为true，或者没有初始化标志文件
              if [ "$FORCE_INIT" = "true" ] || [ ! -f "{{ $path }}/.data_initialized" ]; then
                if [ -d "/temp-data{{ $path }}" ]; then
                  echo "将 {{ $path }} 的原始数据迁移到持久卷..."
                  # 确保目标目录存在
                  mkdir -p {{ $path }}
                  # 将临时存储中的数据递归复制到实际挂载点
                  if command -v rsync > /dev/null 2>&1; then
                    # 如果有rsync就用rsync，保留权限和属性
                    rsync -a "/temp-data{{ $path }}/" "{{ $path }}/" 2>/dev/null || true
                  else
                    # 创建所有子目录结构
                    find "/temp-data{{ $path }}" -type d | sed "s|^/temp-data||" | xargs -I{} mkdir -p "{}" 2>/dev/null || true
                    # 复制所有文件，保留权限
                    find "/temp-data{{ $path }}" -type f | while read SRC; do
                      DEST=$(echo $SRC | sed "s|^/temp-data||")
                      cp -a "$SRC" "$DEST" 2>/dev/null || true
                    done
                    # 复制所有符号链接
                    find "/temp-data{{ $path }}" -type l | while read SRC; do
                      DEST=$(echo $SRC | sed "s|^/temp-data||")
                      cp -a "$SRC" "$DEST" 2>/dev/null || true
                    done
                  fi
                  # 创建标记文件，表示该目录已完成初始化
                  touch {{ $path }}/.data_initialized
                  echo "{{ $path }} 数据迁移完成"
                else
                  echo "{{ $path }} 没有原始数据需要迁移"
                  # 即使没有数据也创建标记文件
                  touch {{ $path }}/.data_initialized
                fi
              else
                echo "{{ $path }} 已初始化，跳过迁移步骤"
              fi
              {{- end }}
              
              # 执行应用的默认启动命令
              # 查找并执行入口点脚本（如果存在）
              if [ -f "/entrypoint.sh" ]; then
                exec /entrypoint.sh "$@"
              # 对于Docker标准入口点
              elif [ -f "/docker-entrypoint.sh" ]; then
                exec /docker-entrypoint.sh "$@"
              # 对于Ubuntu SSH服务器
              elif command -v sshd > /dev/null 2>&1; then
                exec /usr/sbin/sshd -D
              # 对于Web应用
              elif [ -f "/app/start.sh" ]; then
                exec /app/start.sh
              # 对于Node.js应用
              elif [ -f "/app/server.js" ]; then
                exec node /app/server.js
              # 对于Java应用
              elif [ -f "/app/app.jar" ]; then
                exec java -jar /app/app.jar
              # 对于Python应用
              elif [ -f "/app/app.py" ]; then
                exec python /app/app.py
              # 对于通用情况，保持容器运行
              else
                echo "未找到默认启动命令，容器将保持运行..."
                # 保持容器运行
                exec tail -f /dev/null
              fi
          {{- else }}
          # 如果没有持久化卷，直接启动应用
          command:
            - /bin/sh
            - -c
            - |
              # 查找并执行入口点脚本（如果存在）
              if [ -f "/entrypoint.sh" ]; then
                exec /entrypoint.sh "$@"
              # 对于Docker标准入口点
              elif [ -f "/docker-entrypoint.sh" ]; then
                exec /docker-entrypoint.sh "$@"
              # 对于Ubuntu SSH服务器
              elif command -v sshd > /dev/null 2>&1; then
                exec /usr/sbin/sshd -D
              # 根据应用类型自动选择合适的启动命令
              elif [ -f "/app/start.sh" ]; then
                exec /app/start.sh
              else
                # 保持容器运行
                exec tail -f /dev/null
              fi
          {{- if .Values.env }}
          env:
            {{- range $key, $value := .Values.env }}
            - name: {{ $value.name }}
              value: {{ $value.value | quote }}
            {{- end }}
          {{- end }}
          {{- end }}
          {{- if .Values.service.ports }}
          ports:
            {{- range $name, $port := .Values.service.ports }}
            - name: {{ $name }}
              containerPort: {{ $port }}
              protocol: TCP
            {{- end }}
          {{- end }}
          resources:
            {{- toYaml .Values.resources | nindent 12 }}
          volumeMounts:
            {{- if and .Values.persistence.enabled .Values.persistence.mounts }}
            # 挂载持久卷到实际路径
            {{- range $index, $path := .Values.persistence.mounts }}
            - name: data
              mountPath: {{ $path }}
            {{- end }}
            # 挂载临时数据卷
            - name: temp-data
              mountPath: /temp-data
            {{- end }}
      volumes:
        {{- if and .Values.persistence.enabled .Values.persistence.mounts }}
        # 持久卷
        - name: data
          persistentVolumeClaim:
            claimName: {{ include "ubuntu-22-04.fullname" . }}
        # 临时数据卷
        - name: temp-data
          emptyDir: {}
        {{- end }}